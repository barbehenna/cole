# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compound decision method for multivariate linear models
#'
#' The function uses EM algorithm to solve multivariate linear regression
#' problems  \deqn{Y = XB + \epsilon} ' both outcome \eqn{Y} and
#' feature \eqn{X} are multi-dimensional. Users can set distinct residual
#' estimations fordifferent outcomes or set identical estimation for more
#' robust results. Details can be found in
#' \href{https://github.com/sdzhao/cole}{our paper}.
#'
#' @param y      \eqn{n x q} matrix of outcomes for training.
#' @param x      \eqn{n x p} matrix of features for training.
#' @param S      \eqn{d x L} matrix of support points. If \eqn{L = p + 1},
#'               then the first p columns are \eqn{\beta}s and the last
#'               column is the corresponding residual error estimates.
#'               If \eqn{L = p}, then each column of S is a vector of
#'               \eqn{\beta}s and argument min_s2 is required.
#'               \eqn{d = q x g} where g is the number of groups of
#'               support points. Support points can be estimated by
#'               other methods that solve multivariate linear regression.
#'               Eg. LASSO from glmnet.
#' @param tol    error tolerance for convergence of EM algorithm.
#'               Default value of tol is 1e-6.
#' @param maxit  maximum number of allowable iterations.
#'               Default value of maxit is 1e5.
#' @param min_s2 a positive number corresponds to minimal variance
#'               of estimated y, min_s2 is required when there are
#'               `p` columns in `S`.
#' @return
#'
#' - `f`: vector with \eqn{g x q} elements that describes the mixture of
#'        \eqn{\beta}s.
#' - `A`: matrix with dimension \eqn{q x d}. `A` is an estimation of likelihood
#'        by EM algorithm and will be used in predicting.
#' - `bs`: Matrix with dimension \eqn{d x (p + 1)}. `bs` is support points
#'         used in updating prior distribution `f`. `bs` is equivalent to `S`
#'         when \eqn{L = p + 1} and will be used in predicting.
#'
#' @examples
#' \donttest{
#' ## generate data
#' p = 10
#' q = 5
#' n = 50
#' x = matrix(rnorm(n*p,0,10), n, p)
#' beta = matrix(rnorm(p*q,0,10), q, p)
#' e = matrix(rnorm(n*q,0,0.1),n,q)
#' y = x %*% t(beta) + e
#' s2 = matrix(rep(0.1,q), q, 1)
#' ## initialize parameters for EM algorithm
#' x_test = matrix(rnorm(n*p,0,1), n, p)
#' ## set minimal variance estimation min_s2 = 0.1
#' output1 = comte(y=y, x=x, S=beta, min_s2=0.1)
#' ## use distinct variance from multivariate linear regression models
#'output2 = comte(y=y, x=x, S=cbind(beta,s2))
#' }
#'
#' @useDynLib cole
#' @export
comte <- function(y, x, S, tol = 1e-6, maxit = 1e5L, min_s2 = NULL, scale = 1, cutoff = 0) {
    .Call('_cole_comte', PACKAGE = 'cole', y, x, S, tol, maxit, min_s2, scale, cutoff)
}

#' Predicting function for compound decision method
#'
#' The function takes returned object from comte and testing data as input.
#' Return value is the prediction for corresponding output.
#'
#' @param comte_obj returned object from comte function that contains
#'                  important information for predicting.
#' @param newx      \eqn{m x p} matrix corresponds to testing data.
#'
#' @return
#'
#' - `esty`: \eqn{m x q} matrix of estimated y based on newx.
#'
#' @examples
#' \donttest{
#' ## generate data
#' p = 10
#' q = 5
#' n = 50
#' x = matrix(rnorm(n*p,0,10), n, p)
#' beta = matrix(rnorm(p*q,0,10), q, p)
#' e = matrix(rnorm(n*q,0,0.1),n,q)
#' y = x %*% t(beta) + e
#' s2 = matrix(rep(0.1,q), q, 1)
#' ## initialize parameters for EM algorithm
#' x_test = matrix(rnorm(n*p,0,1), n, p)
#' ## set minimal variance estimation min_s2 = 0.1
#' output1 = comte(y=y, x=x, S=beta, min_s2=0.1)
#' esty1 = predict_comte(output1, x_test)
#' ## use distinct variance from multivariate linear regression models
#'	output2 = comte(y=y, x=x, S=cbind(beta,s2))
#' esty2 = predict_comte(output2, x_test)
#' }
#'
#' @useDynLib cole
#' @export
predict_comte <- function(comte_obj, newx) {
    .Call('_cole_predict_comte', PACKAGE = 'cole', comte_obj, newx)
}

rep_time <- function(s, times) {
    .Call('_cole_rep_time', PACKAGE = 'cole', s, times)
}

rep_each <- function(s, each) {
    .Call('_cole_rep_each', PACKAGE = 'cole', s, each)
}

npmle_c <- function(D, maxit = 200L, tol = 0.0001, verbose = FALSE) {
    .Call('_cole_npmle_c', PACKAGE = 'cole', D, maxit, tol, verbose)
}

#' Matrix shrinkage by g-modeling method
#' 
#' The function use shrinkage method to estimate covariance matrix with given multinormal data. 
#' This method applies empirical method and approximate the optimal separable decision rule by
#' EM algorithm.
#' 
#' @param X          \eqn{n x p} matrix of data generated from p-variate multivariate normal distribution
#' @param d          interger. It controls the number of support points. Default value is 10.
#' @param centered   bool. Whether X has been centered. If center=false, it is known that the multivariate
#'                   distribution has mean of zeros. Otherwise means are unknown. Default value is false.
#' @param maxit      maximum number of allowable iterations. Default value is 200.
#' @param tol        error tolerance for convergence of EM algorithm. Default value is 1e-04.
#' @param verbose    bool. Whether print out error information during EM iteration. Default value is false.
#' @return 
#' 
#' - `est_cov`: \eqn{p x p} matrix of estiamted covariance matrix.
#' 
#' @examples
#' \donttest{
#' ## set parameters
#' p = 10
#' d = 20
#' n = 100
#' ## generate multivariate normal data X, with mean of zeros and identity matrix as covariance matrix.
#' X = matrix(rnorm(n*p,0,1), n, p)
#' ## estimate covariance with given data X
#' cov = msg(X=X, d=d)
#' }
#' 
#' @useDynLib cole
#' @export
msg <- function(X, d = 10L, centered = FALSE, maxit = 200L, tol = 0.0001, verbose = FALSE) {
    .Call('_cole_msg', PACKAGE = 'cole', X, d, centered, maxit, tol, verbose)
}

